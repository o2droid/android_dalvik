#!/bin/bash
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# opcode-gen <file>
#
# This script uses the file bytecodes.txt (in this directory) to
# generate code inside the given <file>, based on the directives found
# in that file:
#
#     opcodes:   static final ints for each opcode
#     dops:      static final objects for each opcode
#     dops-init: initialization code for the "dops"

file="$1"
tmpfile="/tmp/$$.txt"

if [ "x$1" = "x" ]; then
    echo "must specify a file"
    exit 1
fi

# Set up prog to be the path of this script, including following symlinks,
# and set up progdir to be the fully-qualified pathname of its directory.
prog="$0"
while [ -h "${prog}" ]; do
    newProg=`/bin/ls -ld "${prog}"`
    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
    if expr "x${newProg}" : 'x/' >/dev/null; then
        prog="${newProg}"
    else
        progdir=`dirname "${prog}"`
        prog="${progdir}/${newProg}"
    fi
done
oldwd=`pwd`
progdir=`dirname "${prog}"`
cd "${progdir}"
progdir=`pwd`
prog="${progdir}"/`basename "${prog}"`
cd "${oldwd}"

bytecodeFile="$progdir/bytecode.txt"

awk -v "bytecodeFile=$bytecodeFile" '

BEGIN {
    readBytecodes();
    consumeUntil = "";
}

consumeUntil != "" {
    if (index($0, consumeUntil) != 0) {
        consumeUntil = "";
    } else {
        next;
    }
}

/BEGIN\(opcodes\)/ {
    consumeUntil = "END(opcodes)";
    print;

    for (i = 0; i < 256; i++) {
        printf("    public static final int %s = 0x%s;\n",
               uppername[i], hex[i]);
    }

    next;
}

/BEGIN\(dops\)/ {
    consumeUntil = "END(dops)";
    print;

    for (i = 0; i < 256; i++) {
        if (index(name[i], "unused") != 0) {
            continue;
        }
        printf("    public static final Dop %s =\n" \
               "        new Dop(DalvOps.%s, DalvOps.%s,\n" \
               "            Form%s.THE_ONE, %s, \"%s\");\n\n",
               uppername[i], uppername[i], family[i], format[i], hasres[i],
               name[i]);
    }

    next;
}

/BEGIN\(dops-init\)/ {
    consumeUntil = "END(dops-init)";
    print;

    for (i = 0; i < 256; i++) {
        if (index(name[i], "unused") != 0) {
            continue;
        }
        printf("        set(%s);\n", uppername[i]);
    }

    next;
}

{ print; }

# Read the bytecode description file.
function readBytecodes(i, parts, line, cmd, status, count) {
    # locals: parts, line, cmd, status, count
    for (;;) {
        # Read a line.
        status = getline line <bytecodeFile;
        if (status == 0) break;
        if (status < 0) {
            print "trouble reading bytecode file";
            exit 1;
        }

        # Clean up the line and extract the command
        gsub(/  */, " ", line);
        sub(/ *#.*$/, "", line);
        sub(/ $/, "", line);
        sub(/^ /, "", line);
        count = split(line, parts);
        if (count == 0) continue; # Blank or comment line.
        cmd = parts[1];
        sub(/^[a-z][a-z]* */, "", line); # Remove the command from line.

        if (cmd == "op") {
            status = defineOpcode(line);
        } else if (cmd == "format") {
            status = defineFormat(line);
        } else {
            status = -1;
        }

        if (status != 0) {
            printf("syntax error on line: %s\n", line);
        }
    }
}

# Define an opcode.
function defineOpcode(line, count, parts, idx) {
    # locals: count, parts, idx
    count = split(line, parts);
    if (count != 4)  return -1;
    idx = parseHex(parts[1]);
    if (idx < 0) return -1;

    hex[idx] = parts[1];
    format[idx] = parts[2];
    hasres[idx] = (parts[3] == "n") ? "false" : "true";
    name[idx] = parts[4];
    uppername[idx] = toupper(parts[4]);
    gsub("[---/]", "_", uppername[idx]);
    split(name[idx], parts, "/");
    family[idx] = toupper(parts[1]);
    gsub("-", "_", family[idx]);

    return 0;
}

# Define a format family.
function defineFormat(line, count, parts) {
    # locals: count, parts
    count = split(line, parts);
    if (count < 1)  return -1;
    formats[parts[1]] = line;
    return 0;
}

# Convert a hex value to an int.
function parseHex(hex, result, chars, count, c, i) {
    # locals: result, chars, count, c, i
    hex = tolower(hex);
    count = split(hex, chars, "");
    result = 0;
    for (i = 1; i <= count; i++) {
        c = index("0123456789abcdef", chars[i]);
        if (c == 0) {
            printf("bogus hex value: %s\n", hex);
            return -1;
        }
        result = (result * 16) + c - 1;
    }
    return result;
}
' "$file" > "$tmpfile"

cp "$tmpfile" "$file"
rm "$tmpfile"
